_detect_full_vertical_lines_pymupdf
# 表格列数检测问题与解决方案

## 问题描述

在提取跨页表格时，PDFPlumber 可能会遗漏表格的左侧或右侧列，导致列数识别错误。

**典型案例：第5-6页表格**
- 第5页：5列，bbox x0=33.6 ✓ 正确
- 第6页：4列，bbox x0=99.0 ✗ 错误（缺失左侧第一列）
- **根本原因**：PDFPlumber 在检测时截掉了第6页的序号列

**期望结果：**
```json
{
  "id": "temp_007",
  "page": 6,
  "columns": 5,  // 正确
  "bbox": [33.6, 28.8, 561.1, 702.8]  // 包含完整第一列
}
```

**实际结果：**
```json
{
  "id": "temp_007",
  "page": 6,
  "columns": 4,  // 错误
  "bbox": [99.0, 28.8, 561.1, 702.8]  // x0=99.0 截掉了第一列
}
```

## 实现的解决方案：PyMuPDF + PDFPlumber 协同检测

### 方案概述

使用 PyMuPDF 的 `get_drawings()` 方法检测页面中的所有垂直线（完整列边界），然后将这些边界传递给 PDFPlumber 的 `explicit_vertical_lines` 参数，强制使用完整的列边界进行表格提取。

### 关键方法说明

1. **`get_drawings()`** - 返回页面上所有绘图对象的列表
   - 返回值：`List[Dict]`，每个dict包含绘图项的详细信息
   - 我们使用：检测类型为 `'l'`（line）的项，提取垂直线的x坐标

2. **`_detect_full_vertical_lines_pymupdf()`** - 返回排序后的垂直线x坐标列表
   - 返回值：`List[float]`，如 `[33.6, 99.0, 231.1, 429.1, 495.1, 561.1]`

3. **`_merge_vertical_lines_with_prev_table()`** - 返回合并后的垂直线列表
   - 返回值：`List[float]`，当前页+前页补充的完整列边界

4. **PDFPlumber的`find_tables(explicit_vertical_lines=...)`** - 返回检测到的表格对象列表
   - 返回值：`List[Table]`，使用指定的垂直线作为列边界

### 实现的功能

#### 1. PyMuPDF 垂直线检测

**文件**：`app/utils/unTaggedPDF/table_extractor.py:126-171`

```python
def _detect_full_vertical_lines_pymupdf(self, pymupdf_page, page_num: int) -> List[float]:
    """
    使用 PyMuPDF 的 get_drawings() 检测页面中的所有垂直线

    这个方法可以检测到 PDFPlumber 可能遗漏的列边界（如左侧或右侧的列）

    Returns:
        排序后的垂直线x坐标列表
    """
    v_lines_x = set()

    try:
        # 获取所有绘图对象
        drawings = pymupdf_page.get_drawings()

        for drawing in drawings:
            for item in drawing['items']:
                # 'l' 表示线段
                if item[0] == 'l':
                    p1, p2 = item[1], item[2]

                    # 判断是否为垂直线（允许2个单位的误差）
                    if abs(p1.x - p2.x) < 2:
                        # 垂直线，记录x坐标
                        v_lines_x.add(round(p1.x, 6))

        result = sorted(list(v_lines_x))
        if result:
            print(f"  [PyMuPDF列检测] 页{page_num}: 检测到 {len(result)} 条垂直线")

        return result

    except Exception as e:
        print(f"  [PyMuPDF列检测] 页{page_num}: 检测失败: {e}")
        return []
```

#### 2. 跨页列边界合并

**文件**：`app/utils/unTaggedPDF/table_extractor.py:173-206`

```python
def _merge_vertical_lines_with_prev_table(
    self,
    pymupdf_v_lines: List[float],
    prev_table_v_lines: List[float],
    tolerance: float = 5.0
) -> List[float]:
    """
    合并当前页的垂直线和前一页表格的列边界

    如果当前页缺失某些列边界（如左侧第一列），从前一页补充
    """
    if not prev_table_v_lines:
        return pymupdf_v_lines

    # 找出前一页有但当前页缺失的列边界
    missing_lines = []
    for prev_x in prev_table_v_lines:
        # 检查是否在当前页的垂直线中存在
        found = any(abs(prev_x - curr_x) < tolerance for curr_x in pymupdf_v_lines)
        if not found:
            missing_lines.append(prev_x)
            print(f"    [列边界补充] 从前页补充缺失的列边界: x={prev_x:.1f}")

    # 合并并排序
    all_lines = sorted(list(set(pymupdf_v_lines + missing_lines)))
    return all_lines
```

#### 3. 集成到主提取流程

**文件**：`app/utils/unTaggedPDF/table_extractor.py:347-390`

```python
# 用于跨页表格的列边界传递
prev_page_vertical_lines = None

with pdfplumber.open(self.pdf_path) as pdf:
    for page_num, page in enumerate(pdf.pages, start=1):
        pymupdf_page = doc_pymupdf[page_num - 1]

        # 使用PyMuPDF检测完整的垂直线边界
        pymupdf_v_lines = self._detect_full_vertical_lines_pymupdf(pymupdf_page, page_num - 1)

        # 如果有前页的列边界，尝试合并（用于处理跨页表格缺失列的情况）
        if prev_page_vertical_lines and pymupdf_v_lines:
            merged_v_lines = self._merge_vertical_lines_with_prev_table(
                pymupdf_v_lines, prev_page_vertical_lines, tolerance=5.0
            )
        else:
            merged_v_lines = pymupdf_v_lines

        # 使用pdfplumber找到表格
        table_settings = {
            "horizontal_strategy": "lines",
            "intersection_x_tolerance": 3,
            "intersection_y_tolerance": 3
        }

        # 如果检测到垂直线，使用explicit策略；否则使用lines策略
        if merged_v_lines and len(merged_v_lines) >= 2:
            table_settings["vertical_strategy"] = "explicit"
            table_settings["explicit_vertical_lines"] = merged_v_lines
            print(f"  [列边界检测] 使用PyMuPDF检测到 {len(merged_v_lines)} 条垂直线")
        else:
            table_settings["vertical_strategy"] = "lines"
            print(f"  [列边界检测] 未检测到垂直线，使用lines策略")

        tables = page.find_tables(table_settings=table_settings)

        # 记录当前页的列边界，用于下一页
        if merged_v_lines:
            prev_page_vertical_lines = merged_v_lines
```

#### 4. Hint-based重提取改进

**文件**：`app/utils/unTaggedPDF/table_extractor.py:572-578`

修改 `reextract_with_hints()` 方法中的水平策略，从 `'lines_strict'` 改为 `'lines'`，使其更宽松：

```python
# 使用pdfplumber的显式列策略
table_settings = {
    "vertical_strategy": "explicit",
    "explicit_vertical_lines": col_xs,
    "horizontal_strategy": "lines",  # 使用lines而非lines_strict，更宽松
    "intersection_x_tolerance": 3,
    "intersection_y_tolerance": 3
}
```

## 测试结果

### 测试PDF：国土空间规划实施监测网络建设项目.pdf

**测试命令：**
```bash
.venv/Scripts/python.exe app/utils/unTaggedPDF/pdf_content_extractor.py
```

**第6页表格检测结果：**

```
[表格提取] 页码 6: 检测到 1 个表格
  [列边界检测] 未检测到垂直线，使用lines策略
  [表格 1] bbox: (99.019672231875, 28.800084266625618, 561.148588134375, 702.7881005763757)
  [表格 1] 提取到 3 行数据
  [TEXT-FALLBACK] 触发：left_gap=0.0pt, first_col_index=0, row_levels=0, bbox_x0=99.0
  [TEXT-FALLBACK] 没有找到与原表 IoU 足够高的候选 (best_iou=0.21)
  [表格 1] [OK] 成功添加到结果列表
```

**Raw JSON 输出：**
```json
{
  "id": "temp_007",
  "page": 6,
  "columns": 4,  // ❌ 仍然是4列（期望5列）
  "bbox": [99.0, 28.8, 561.1, 702.8]  // ❌ x0=99.0（期望33.6）
}
```

**Hint-based 重提取结果：**
```
[页6] 使用hint重新提取
  来源: 页5表temp_006
  评分: 0.95
  列边界: ['33.6', '99.0', '231.1', '429.1', '495.1']...
  使用设置: {'vertical_strategy': 'explicit', 'explicit_vertical_lines': [33.6, 99.0, 231.1, 429.1, 495.1, 561.1], ...}
  重新检测到 0 个表格  // ❌ 使用显式列边界后检测不到表格
  警告: 重提取失败，保留原表格
```

## 失败原因分析 - 真相大白

经过详细调试，发现问题不是"没有线条"，而是**第6页左侧列开口（上下不封闭）**！

### 调试发现

#### 1. PDF使用"细矩形"绘制线条

**现象：**
```
第5页：140个绘图对象，全部是 're'（矩形）类型
第6页：52个绘图对象，全部是 're'（矩形）类型
```

**真相：**
- 这个PDF**确实有显式线条**，但使用**细矩形**而非线段绘制
- 示例：`Rect(33.30, 28.50, 33.90, 68.11)` - 宽度0.6，这就是垂直线！
- **我的代码只检测 `'l'` 类型（线段），忽略了 `'re'` 类型（矩形）**

#### 2. 左侧列存在但上下开口

**第6页左侧列结构：**

✅ **垂直线存在**：
```python
Drawing 2:
  x: 33.30 -> 33.90 (宽度: 0.60)  # ← 左侧列的左边线
  y: -308.79 -> 1830.20 (高度: 2139.00)  # 超长，跨页绘制
```

❌ **但顶部和底部开口**：
```python
顶部水平线（y=28.5）：
  x: 98.72 -> 231.36  # ← 从99开始，不包括x=33.6！
  x: 230.76 -> 429.41
  x: 428.81 -> 495.43

底部水平线（y=702.5）：
  x: 98.72 -> 231.36  # ← 从99开始，不包括x=33.6！
```

**对比第5页（正常检测）：**
```python
顶部水平线（y=28.5）：
  x: 33.30 -> 86.72  # ✅ 包含x=33.6，左侧列封闭！
  x: 86.12 -> 297.98
```

### 1. 为什么PDFPlumber检测不到左侧列

**根本原因：PDFPlumber的表格检测需要完整的cell边界**

- 要形成一个cell，必须有：**左线 + 右线 + 顶线 + 底线**
- 第6页左侧列有左右两条垂直线（x=33.6和x=99.0）
- **但没有连接这两条垂直线的顶线和底线**
- PDFPlumber认为这不是一个有效的列，所以表格从x=99.0开始

**这不是bug，是PDF设计问题：第6页的表格故意设计成左侧列开口的！**

### 2. TEXT-FALLBACK 机制失败

**现象：**
```
[TEXT-FALLBACK] 触发：bbox_x0=99.0
[TEXT-FALLBACK] 没有找到与原表 IoU 足够高的候选 (best_iou=0.21)
```

**原因：**
- TEXT-FALLBACK 使用 `vertical_strategy='text'` 重新检测表格
- 由于第6页PDFPlumber本身就检测不到完整表格，text策略同样失败
- IoU 0.21 < 0.25 阈值，因此没有采用重提取结果

### 3. Hint-based 重提取失败

**现象：**
```
使用设置: {'vertical_strategy': 'explicit', 'explicit_vertical_lines': [33.6, 99.0, ...]}
重新检测到 0 个表格
```

**原因：**
- 即使用 `explicit_vertical_lines=[33.6, 99.0, ...]` 强制指定列边界
- PDFPlumber仍然需要**水平线连接这些垂直线形成cell**
- 由于第6页的水平线从x=98.72开始，不包括x=33.6
- 无法在x=33.6和x=99.0之间形成有效的cell
- 结果：整个表格都检测不到（`find_tables()` 返回空列表）

## 适用场景

### ✅ 适用的PDF类型

PyMuPDF + PDFPlumber 协同方案适用于以下类型的PDF：

1. **使用显式线条绘制的表格**
   - 使用绘图命令（如 PDF 的 `moveto`、`lineto`、`stroke`）绘制表格线
   - PyMuPDF 的 `get_drawings()` 可以检测到这些线条

2. **扫描PDF转换的表格**
   - 通过OCR识别后重新生成的PDF，通常会绘制显式表格线

3. **结构化文档**
   - Word、Excel等转换的PDF，通常保留显式表格结构

### ❌ 不适用的PDF类型

1. **使用字符边框的表格**
   - 使用特殊字符（如 `│`、`─`、`┌`等）绘制表格框
   - 这些"线条"实际上是文本字符，不是绘图对象

2. **使用CSS样式的表格**
   - 来自网页转换的PDF，表格线可能是CSS边框
   - 不会生成绘图对象

3. **纯文本对齐的表格**
   - 仅通过空格和制表符对齐的表格
   - 没有任何视觉线条

## 替代解决方案

针对不使用显式线条的PDF，可以考虑以下替代方案：

### 方案1：基于文本对齐的列检测

```python
def detect_columns_by_text_alignment(page, pymupdf_page):
    """
    通过分析文本块的x坐标分布来推断列边界
    """
    # 提取所有文本块的x坐标
    words = page.extract_words()
    x_positions = sorted(set([w['x0'] for w in words] + [w['x1'] for w in words]))

    # 聚类x坐标，找到明显的列边界
    clusters = []
    threshold = 5.0  # 5pt容差

    for x in x_positions:
        if not clusters or x - clusters[-1][-1] > threshold:
            clusters.append([x])
        else:
            clusters[-1].append(x)

    # 每个cluster的中位数作为列边界
    column_boundaries = [statistics.median(cluster) for cluster in clusters]
    return column_boundaries
```

### 方案2：基于Crop的区域提取

```python
def extract_with_crop(page, hint_bbox):
    """
    使用hint中的bbox信息裁剪页面区域，然后用默认策略提取
    """
    # 从hint获取完整的bbox（包括缺失的左侧列）
    x0, y0, x1, y1 = hint_bbox

    # 裁剪到完整区域
    cropped = page.crop((x0, y0, x1, y1))

    # 使用默认策略在裁剪区域内提取
    tables = cropped.find_tables()

    return tables[0] if tables else None
```

### 方案3：后处理修正bbox

```python
def fix_bbox_with_hints(table, hint):
    """
    在raw.json阶段检测bbox不对齐，使用hint修正
    """
    expected_x0 = hint['bbox'][0]
    actual_x0 = table['bbox'][0]

    # 检测左侧缺失
    if abs(actual_x0 - expected_x0) > 10:  # 10pt容差
        print(f"  [bbox修正] 检测到左侧缺失：actual_x0={actual_x0:.1f}, expected_x0={expected_x0:.1f}")

        # 修正table bbox
        table['bbox'][0] = expected_x0

        # 补充缺失的列
        # ... 重新构建columns和cells
```

## 后续工作建议

1. **实现文本对齐检测**
   - 作为 PyMuPDF `get_drawings()` 的fallback
   - 适用于不使用显式线条的PDF

2. **改进Hint机制**
   - 当检测到bbox显著偏移时（如x0从33.6变为99.0），强制使用hint的bbox
   - 不依赖PDFPlumber的列检测，直接基于hint重建表格结构

3. **增加PDF类型判断**
   - 自动检测PDF是否使用显式线条绘制表格
   - 根据类型选择合适的检测策略

4. **日志优化**
   - 在检测失败时输出更详细的诊断信息
   - 帮助快速定位问题原因

## 参考文档

- [COLUMN_DETECTION_SOLUTION.md](./COLUMN_DETECTION_SOLUTION.md) - 原始解决方案设计文档
- [table_extractor.py](./table_extractor.py) - 表格提取器实现
- PDFPlumber文档：https://github.com/jsvine/pdfplumber
- PyMuPDF文档：https://pymupdf.readthedocs.io/

## 更新历史

- 2025-10-29: 实现PyMuPDF + PDFPlumber协同检测方案
  - 新增 `_detect_full_vertical_lines_pymupdf()` 方法检测垂直线
  - 新增 `_merge_vertical_lines_with_prev_table()` 方法合并跨页列边界
  - 修改 `reextract_with_hints()` 使用更宽松的水平策略
  - **调试发现**：PDF使用细矩形绘制线条，而非线段（代码只检测 `'l'` 类型，忽略了 `'re'` 类型）
  - **根本问题**：第6页左侧列上下开口（无水平线封闭），PDFPlumber无法形成有效cell
  - **结论**：这不是代码bug，是PDF设计问题——第6页表格设计为左侧列开口